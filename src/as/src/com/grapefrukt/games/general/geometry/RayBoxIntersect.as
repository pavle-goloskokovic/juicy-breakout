package com.grapefrukt.games.general.geometry {	import flash.geom.Point;	import flash.geom.Rectangle;		// based on code stolen from http://wessite.com/2010/12/as3-ray-box-intersection		public class RayBoxIntersect {			public static const IN	:int = 0;		public static const OUT	:int = 1;				public static function rayBoxIntersect(r1:Point, r2:Point, box:Rectangle):Vector.<Point> {						if ((box.x + box.width) < Math.min(r1.x, r2.x) || box.x > Math.max(r1.x, r2.x)) return null;			if ((box.y + box.height) < Math.min(r1.y, r2.y) || box.y > Math.max(r1.y, r2.y)) return null;						var intersections:Vector.<Point>;			var tnear:Number;	// near value on plane			var tfar:Number;	// far value on plane						tnear = Math.max((box.x - r1.x) / (r2.x - r1.x), (box.y - r1.y) / (r2.y - r1.y));			tfar = Math.min(((box.x + box.width) - r1.x) / (r2.x - r1.x), ((box.y + box.height) - r1.y) / (r2.y - r1.y));			if (tnear < tfar) {				intersections = new Vector.<Point>(2, true);				if (tnear >=0 && tnear <= 1) intersections[IN] = Point.interpolate(r2, r1, tnear);				if (tfar >= 0 && tfar <= 1) intersections[OUT] = Point.interpolate(r2, r1, tfar);				return intersections;			}						tnear = Math.min((box.x - r1.x) / (r2.x - r1.x), (box.y - r1.y) / (r2.y - r1.y));			tfar = Math.max(((box.x + box.width) - r1.x) / (r2.x - r1.x), ((box.y + box.height) - r1.y) / (r2.y - r1.y));			if (tnear > tfar) {				intersections = new Vector.<Point>(2, true);				if (tfar >= 0 && tfar <= 1) intersections[IN] = Point.interpolate(r2, r1, tfar);				if (tnear >=0 && tnear <= 1) intersections[OUT] = Point.interpolate(r2, r1, tnear);				return intersections;			}						tnear = Math.min(((box.x + box.width) - r1.x) / (r2.x - r1.x), (box.y - r1.y) / (r2.y - r1.y));			tfar = Math.max((box.x - r1.x) / (r2.x - r1.x), ((box.y + box.height) - r1.y) / (r2.y - r1.y));			if (tnear > tfar) {				intersections = new Vector.<Point>(2, true);				if (tfar >= 0 && tfar <= 1) intersections[IN] = Point.interpolate(r2, r1, tfar);				if (tnear >=0 && tnear <= 1) intersections[OUT] = Point.interpolate(r2, r1, tnear);				return intersections;			}						tnear = Math.max(((box.x + box.width) - r1.x) / (r2.x - r1.x), (box.y - r1.y) / (r2.y - r1.y));			tfar = Math.min((box.x - r1.x) / (r2.x - r1.x), ((box.y + box.height) - r1.y) / (r2.y - r1.y));			if (tnear < tfar) {				intersections = new Vector.<Point>(2, true);				if (tnear >=0 && tnear <= 1) intersections[IN] = Point.interpolate(r2, r1, tnear);				if (tfar >= 0 && tfar <= 1) intersections[OUT] = Point.interpolate(r2, r1, tfar);				return intersections;			}						return null;		}				public static function rayBoxIntersectFast(r1:Point, r2:Point, box:Rectangle, output:Point):Boolean {						if ((box.x + box.width) < Math.min(r1.x, r2.x) || box.x > Math.max(r1.x, r2.x)) return false;			if ((box.y + box.height) < Math.min(r1.y, r2.y) || box.y > Math.max(r1.y, r2.y)) return false;						var tnear:Number;	// near value on plane			var tfar:Number;	// far value on plane			var interpolate:Number = -1;						while(1){				tnear = Math.max((box.x - r1.x) / (r2.x - r1.x), (box.y - r1.y) / (r2.y - r1.y));				tfar = Math.min(((box.x + box.width) - r1.x) / (r2.x - r1.x), ((box.y + box.height) - r1.y) / (r2.y - r1.y));				if (tnear < tfar) {					if (tnear >= 0 && tnear <= 1) interpolate = tnear;					break;				}								tnear = Math.min((box.x - r1.x) / (r2.x - r1.x), (box.y - r1.y) / (r2.y - r1.y));				tfar = Math.max(((box.x + box.width) - r1.x) / (r2.x - r1.x), ((box.y + box.height) - r1.y) / (r2.y - r1.y));				if (tnear > tfar) {					if (tfar >= 0 && tfar <= 1) interpolate = tfar;					break;				}								tnear = Math.min(((box.x + box.width) - r1.x) / (r2.x - r1.x), (box.y - r1.y) / (r2.y - r1.y));				tfar = Math.max((box.x - r1.x) / (r2.x - r1.x), ((box.y + box.height) - r1.y) / (r2.y - r1.y));				if (tnear > tfar) {					if (tfar >= 0 && tfar <= 1)  interpolate = tfar;					break;				}								tnear = Math.max(((box.x + box.width) - r1.x) / (r2.x - r1.x), (box.y - r1.y) / (r2.y - r1.y));				tfar = Math.min((box.x - r1.x) / (r2.x - r1.x), ((box.y + box.height) - r1.y) / (r2.y - r1.y));				if (tnear < tfar) {					if (tnear >= 0 && tnear <= 1) interpolate = tnear;					break;				}								// no luck!				break;			}						if (interpolate != -1) {				output.x = r1.x + (r2.x - r1.x) * interpolate;				output.y = r1.y + (r2.y - r1.y) * interpolate;				return true;			}						return false;		}			}}